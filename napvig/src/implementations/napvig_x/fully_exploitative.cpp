#include "napvig_x.h"

using namespace std;
using namespace torch;

Tensor saturate (const Tensor &x, double maxValue) {
	Tensor saturated = (x > maxValue);

	return saturated * maxValue + (~saturated) * x;
}

FullyExploitative::FullyExploitative(const std::shared_ptr<Landscape> &_landscape,
									 const std::shared_ptr<NapvigX::Params> &_params,
									 const std::shared_ptr<Frame> &_targetFrame):
	Policy(_landscape, _params),
	targetFrame(_targetFrame)
{}

pair<Tensor,boost::optional<Tensor>> FullyExploitative::searchTowardsTarget(const Tensor &currentPosition)
{
	torch::Tensor diff = (targetFrame->position - currentPosition);

	return {diff / diff.norm (),
				saturate (diff.norm () / params().stepGainSaturationDistance, 1)};
}

bool FullyExploitative::checkTargetReached () const {
	return targetFrame->position.norm ().item().toDouble () < params().targetReachedThreshold;
}

pair<Tensor,boost::optional<Tensor>> FullyExploitative::getFirstSearch(const Napvig::State &initialState) {
	return searchTowardsTarget (initialState.position);
}

pair<Tensor,boost::optional<Tensor>> FullyExploitative::getNextSearch(const Napvig::Trajectory &trajectory) {
	return searchTowardsTarget (trajectory.back ().position);
}

Policy::Termination FullyExploitative::terminationCondition (const Napvig::Trajectory &trajectory)
{
	Termination collisionTerminated = CollisionTerminatedPolicy::terminationCondition (trajectory);

	if (collisionTerminated == PREDICTION_TERMINATION_NONE) {
		if (checkTargetReached ())
			return PREDICTION_TERMINATION_TARGET_REACHED;
		return PREDICTION_TERMINATION_NONE;
	}

	return collisionTerminated;
}

bool FullyExploitative::processTrajectory (const Napvig::Trajectory &trajectory, PolicyAbstract::Termination termination)
{
	const int index = 0;

	switch (termination) {
	case PREDICTION_TERMINATION_TARGET_REACHED:
		ROS_ERROR ("TARGET RICED");
		finalTrajectoryIndexed = {boost::none, index};
		break;
	case PREDICTION_TERMINATION_MAX_STEP:
		ROS_INFO ("NON HOVVISTO TUTTO");
		finalTrajectoryIndexed = {trajectory, index};
		break;
	case PREDICTION_TERMINATION_COLLISION:
		ROS_WARN ("COLLIDEEEEEE NO TRAJ");
		finalTrajectoryIndexed = {boost::none, index};
		break;
	default:
		cout << "unexp " << termination << endl;
		break;
	}

	// Fully-Explorative is one-shot, the trajectory either exists or it doesn't
	// So always stop
	return false;
}
